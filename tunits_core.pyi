from typing import ClassVar, Sequence, Any, TypeVar, Callable, Iterator, overload

from numpy._typing import NDArray, DTypeLike, _ShapeLike
from numpy import number

from tunits.proto import tunits_pb2

SCALE_PREFIXES: dict[str, int]

_REAL_NUMERICAL_TYPE = int | float | number[Any]
_NUMERICAL_TYPE = int | float | number[Any] | complex
_NUMERICAL_TYPE_OR_ARRAY = (
    int
    | float
    | complex
    | number[Any]
    | list[_NUMERICAL_TYPE]
    | tuple[_NUMERICAL_TYPE]
    | NDArray[Any]
)
_NUMERICAL_TYPE_OR_ARRAY_OR_UNIT = (
    int
    | float
    | complex
    | number[Any]
    | list[_NUMERICAL_TYPE]
    | tuple[_NUMERICAL_TYPE]
    | NDArray[Any]
    | 'WithUnit'
    | 'Value'
    | 'Complex'
    | 'ValueArray'
)
T = TypeVar('T', bound=WithUnit)
_NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT = (
    int
    | float
    | complex
    | number[Any]
    | list[_NUMERICAL_TYPE]
    | tuple[_NUMERICAL_TYPE]
    | NDArray[Any]
    | 'WithUnit'
)

class UnitMismatchError(TypeError):
    """Incompatible units."""

frac = dict[str, int]

def float_to_twelths_frac(x: float) -> frac:
    """Recognizes floats corresponding to twelths. Returns them as a fraction."""

def frac_div(a: frac, b: frac) -> frac:
    """Returns the quotient of the two given fractions, in least terms."""

def frac_times(a: frac, b: frac) -> frac:
    """Returns the product of the two given fractions, in least terms."""

def frac_least_terms(a: int, b: int) -> frac:
    """
    Returns an equivalent fraction, without common factors between numerator and
    denominator and with the negative sign on the numerator (if present).
    """

def frac_to_double(a: frac) -> float:
    """Converts a fraction to a double approximating its value."""

def gcd(a: int, b: int) -> int: ...

class UnitTerm:
    name: Any
    power: frac

conversion = dict[str, Any]

def conversion_div(a: conversion, b: conversion) -> conversion:
    """
    Returns a conversion equivalent to applying one conversion and un-applying
    another.
    """

def inverse_conversion(a: conversion) -> conversion: ...
def conversion_times(a: conversion, b: conversion) -> conversion:
    """Returns a conversion equivalent to applying both given conversions."""

def conversion_raise_to(base: conversion, exponent: frac) -> conversion:
    """
    Returns a conversion that, if applied several times, would be roughly
    equivalent to the given conversion.

    Precision lose may be unavoidable when performing roots, but we do try to
    use exact results when possible.
    """

def conversion_to_double(c: conversion) -> float:
    """Returns a double that approximates the given conversion."""

def raw_UnitArray(args: Sequence[tuple[str, int, int]]) -> 'UnitArray':
    """
    A factory method the creates and directly sets the items of a UnitArray.
    (__init__ couldn't play this role for backwards-compatibility reasons.)

    :param list((name, power.numer, power.denom)) name_numer_denom_tuples:
        The list of properties that units in the resulting list should have.
    :return UnitArray:
    """

class UnitArray:
    """
    A list of physical units raised to various powers.
    """

    __pyx_vtable__: ClassVar[Any] = ...
    @classmethod
    def __init__(cls, name: str | None = None) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index: int) -> tuple[str, int, int]: ...
    def __gt__(self, other: object) -> bool: ...
    def __iter__(self) -> Iterator[tuple[str, int, int]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, other: UnitArray) -> UnitArray: ...
    def __pow__(self, exponent: Any, modulo: Any = None) -> UnitArray: ...
    def __truediv__(self, other: UnitArray) -> UnitArray: ...

ValueType = TypeVar('ValueType', bound='Value')
ArrayType = TypeVar('ArrayType', bound='ValueArray')

@overload
def raw_WithUnit(
    value: _REAL_NUMERICAL_TYPE,
    conv: conversion | dict[str, Any],
    base_units: UnitArray,
    display_units: UnitArray,
    value_class: type[ValueType] | None = None,
    array_class: type[ArrayType] | None = None,
) -> ValueType: ...
@overload
def raw_WithUnit(
    value: complex,
    conv: conversion | dict[str, Any],
    base_units: UnitArray,
    display_units: UnitArray,
    value_class: type[ValueType] | None = None,
    array_class: type[ArrayType] | None = None,
) -> 'Complex': ...
@overload
def raw_WithUnit(
    value: list[Any] | tuple[Any] | NDArray[Any],
    conv: conversion | dict[str, Any],
    base_units: UnitArray,
    display_units: UnitArray,
    value_class: type[ValueType] | None = None,
    array_class: type[ArrayType] | None = None,
) -> ArrayType: ...
@overload
def raw_WithUnit(
    value: Any,
    conv: conversion | dict[str, Any],
    base_units: UnitArray,
    display_units: UnitArray,
    value_class: type[ValueType] | None = None,
    array_class: type[ArrayType] | None = None,
) -> ArrayType | ValueType | 'Complex':
    """
    A factory method that directly sets the properties of a WithUnit.
    (__init__ couldn't play this role for backwards-compatibility reasons.)
    """

class WithUnit:
    """
    A value with associated physical units.
    """

    __array_priority__: ClassVar[int] = ...
    __pyx_vtable__: ClassVar[Any] = ...
    base_units: UnitArray
    display_units: UnitArray
    factor: float
    is_angle: bool
    numer: int
    denom: int
    exp10: int
    unit: 'Value'
    value: float | complex | NDArray[Any]
    real: 'Value' | 'ValueArray'
    imag: 'Value' | 'ValueArray'
    def __init__(
        self, value: Any, unit: 'WithUnit' | UnitTerm | UnitArray | str | None = None
    ) -> None: ...
    def inBaseUnits(self: T) -> T: ...
    def inUnitsOf(self: T, unit: Any, should_round: bool = False) -> T: ...
    def in_base_units(self: T) -> T: ...
    def isAngle(self) -> bool: ...
    def isCompatible(self, other: Any) -> bool: ...
    def isDimensionless(self) -> bool: ...
    def round(self: T, unit: Any) -> T: ...
    def sqrt(self: T) -> T: ...
    def __array__(self, dtype: DTypeLike = None) -> NDArray[Any]: ...
    def __array_wrap__(self, out_arr: NDArray[Any]) -> NDArray[Any]: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __copy__(self: T) -> T: ...
    def __deepcopy__(self: T) -> T: ...
    def __abs__(self: 'WithUnit') -> 'WithUnit': ...
    def __getitem__(self: T, key: Any) -> T: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def __neg__(self: T) -> T: ...
    def __pos__(self: T) -> T: ...
    def __lt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool | NDArray[Any]: ...
    def __gt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool | NDArray[Any]: ...
    def __le__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool | NDArray[Any]: ...
    def __ge__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool | NDArray[Any]: ...
    def __eq__(self, other: Any) -> bool | NDArray[Any]: ...  # type: ignore[override]
    def __neq__(self, other: Any) -> bool | NDArray[Any]: ...
    def __round__(self) -> int: ...
    def __pow__(self: T, other: Any, modulus: Any = None) -> T: ...
    def __divmod__(self, other: Any) -> tuple[_NUMERICAL_TYPE_OR_ARRAY, 'WithUnit']: ...
    def _value_class(self) -> type['Value']: ...
    def _array_class(self) -> type['ValueArray']: ...

class Value(WithUnit):
    """A floating-point value with associated units."""

    @classmethod
    def from_proto(cls: type[T], msg: tunits_pb2.Value) -> T: ...
    def to_proto(self, msg: tunits_pb2.Value | None = None) -> tunits_pb2.Value: ...
    def __abs__(self: ValueType) -> ValueType: ...
    def __divmod__(self: ValueType, other: Any) -> tuple[_NUMERICAL_TYPE_OR_ARRAY, ValueType]: ...
    @overload
    def __add__(self: ValueType, other: _REAL_NUMERICAL_TYPE) -> ValueType: ...
    @overload
    def __add__(self, other: complex) -> Complex: ...
    @overload
    def __add__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __add__(self, other: T) -> T: ...
    @overload
    def __radd__(self, other: complex) -> Complex: ...
    @overload
    def __radd__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __sub__(self: ValueType, other: _REAL_NUMERICAL_TYPE) -> ValueType: ...
    @overload
    def __sub__(self, other: complex) -> Complex: ...
    @overload
    def __sub__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __sub__(self, other: T) -> T: ...
    @overload
    def __rsub__(self, other: complex) -> Complex: ...
    @overload
    def __rsub__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __truediv__(self: ValueType, other: _REAL_NUMERICAL_TYPE) -> ValueType: ...
    @overload
    def __truediv__(self, other: complex) -> Complex: ...
    @overload
    def __truediv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __truediv__(self, other: T) -> T: ...
    @overload
    def __rtruediv__(self, other: complex) -> Complex: ...
    @overload
    def __rtruediv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mul__(self: ValueType, other: _REAL_NUMERICAL_TYPE) -> ValueType: ...
    @overload
    def __mul__(self, other: complex) -> Complex: ...
    @overload
    def __mul__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mul__(self, other: T) -> T: ...
    @overload
    def __rmul__(self, other: complex) -> Complex: ...
    @overload
    def __rmul__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mod__(self: ValueType, other: _REAL_NUMERICAL_TYPE) -> ValueType: ...
    @overload
    def __mod__(self, other: complex) -> Complex: ...
    @overload
    def __mod__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mod__(self, other: 'Complex') -> Complex: ...
    @overload
    def __mod__(self, other: 'Value') -> Value: ...
    @overload
    def __mod__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __mod__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __rmod__(self, other: complex) -> Complex: ...
    @overload
    def __rmod__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __floordiv__(self: ValueType, other: _REAL_NUMERICAL_TYPE) -> ValueType: ...
    @overload
    def __floordiv__(self, other: complex) -> Complex: ...
    @overload
    def __floordiv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __floordiv__(self, other: 'Complex') -> Complex: ...
    @overload
    def __floordiv__(self, other: 'Value') -> Value: ...
    @overload
    def __floordiv__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __floordiv__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __rfloordiv__(self, other: complex) -> Complex: ...
    @overload
    def __rfloordiv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    def __lt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __gt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __le__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __ge__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __neq__(self, other: Any) -> bool: ...

class Complex(WithUnit):
    """A complex value with associated units."""

    @classmethod
    def from_proto(cls: type[T], msg: tunits_pb2.Value) -> T: ...
    def to_proto(self, msg: tunits_pb2.Value | None = None) -> tunits_pb2.Value: ...
    def __abs__(self) -> Value: ...
    def __divmod__(self, other: Any) -> tuple[_NUMERICAL_TYPE_OR_ARRAY, 'WithUnit']: ...
    @overload
    def __add__(self, other: _REAL_NUMERICAL_TYPE) -> Complex: ...
    @overload
    def __add__(self, other: complex) -> Complex: ...
    @overload
    def __add__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __add__(self, other: 'Complex') -> Complex: ...
    @overload
    def __add__(self, other: 'Value') -> Complex: ...
    @overload
    def __add__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __add__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __radd__(self, other: complex) -> Complex: ...
    @overload
    def __radd__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __sub__(self, other: _REAL_NUMERICAL_TYPE) -> Complex: ...
    @overload
    def __sub__(self, other: complex) -> Complex: ...
    @overload
    def __sub__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __sub__(self, other: 'Complex') -> Complex: ...
    @overload
    def __sub__(self, other: 'Value') -> Complex: ...
    @overload
    def __sub__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __sub__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __rsub__(self, other: complex) -> Complex: ...
    @overload
    def __rsub__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __truediv__(self, other: _REAL_NUMERICAL_TYPE) -> Complex: ...
    @overload
    def __truediv__(self, other: complex) -> Complex: ...
    @overload
    def __truediv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __truediv__(self, other: 'Complex') -> Complex: ...
    @overload
    def __truediv__(self, other: 'Value') -> Complex: ...
    @overload
    def __truediv__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __truediv__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __rtruediv__(self, other: complex) -> Complex: ...
    @overload
    def __rtruediv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mul__(self, other: _REAL_NUMERICAL_TYPE) -> Complex: ...
    @overload
    def __mul__(self, other: complex) -> Complex: ...
    @overload
    def __mul__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mul__(self, other: 'Complex') -> Complex: ...
    @overload
    def __mul__(self, other: 'Value') -> Complex: ...
    @overload
    def __mul__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __mul__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __rmul__(self, other: complex) -> Complex: ...
    @overload
    def __rmul__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mod__(self, other: _REAL_NUMERICAL_TYPE) -> Complex: ...
    @overload
    def __mod__(self, other: complex) -> Complex: ...
    @overload
    def __mod__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __mod__(self, other: 'Complex') -> Complex: ...
    @overload
    def __mod__(self, other: 'Value') -> Complex: ...
    @overload
    def __mod__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __mod__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __rmod__(self, other: complex) -> Complex: ...
    @overload
    def __rmod__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __floordiv__(self, other: _REAL_NUMERICAL_TYPE) -> Complex: ...
    @overload
    def __floordiv__(self, other: complex) -> Complex: ...
    @overload
    def __floordiv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    @overload
    def __floordiv__(self, other: 'Complex') -> Complex: ...
    @overload
    def __floordiv__(self, other: 'Value') -> Complex: ...
    @overload
    def __floordiv__(self, other: 'ValueArray') -> ValueArray: ...
    @overload
    def __floordiv__(self, other: 'WithUnit') -> Any: ...
    @overload
    def __rfloordiv__(self, other: complex) -> Complex: ...
    @overload
    def __rfloordiv__(self, other: list[Any] | tuple[Any] | NDArray[Any]) -> ValueArray: ...
    def __lt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __gt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __le__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __ge__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __neq__(self, other: Any) -> bool: ...

class ValueArray(WithUnit):
    @classmethod
    def from_proto(cls: type[T], msg: tunits_pb2.ValueArray) -> T: ...
    def to_proto(self, msg: tunits_pb2.ValueArray | None) -> tunits_pb2.ValueArray: ...
    def __init__(self, data: Any, unit: Any = None) -> None: ...
    def allclose(self, other: ValueArray, *args: Any, **kwargs: dict[str, Any]) -> bool: ...
    def __array__(self, dtype: DTypeLike = None) -> NDArray[Any]: ...
    def __array_wrap__(self, out_arr: NDArray[Any], context: Any = None) -> NDArray[Any]: ...
    def __copy__(self: ArrayType) -> ArrayType: ...
    def __deepcopy__(self: ArrayType) -> ArrayType: ...
    def __iter__(self) -> Iterator[WithUnit]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    @property
    def dtype(self) -> NDArray[Any]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def shape(self) -> _ShapeLike: ...
    def __abs__(self: ArrayType) -> ArrayType: ...
    def __divmod__(self: ArrayType, other: Any) -> tuple[_NUMERICAL_TYPE_OR_ARRAY, ArrayType]: ...
    def __add__(self: ArrayType, other: Any) -> ArrayType: ...
    def __radd__(self: ArrayType, other: Any) -> ArrayType: ...
    def __sub__(self: ArrayType, other: Any) -> ArrayType: ...
    def __rsub__(self: ArrayType, other: Any) -> ArrayType: ...
    @overload
    def __truediv__(self: ArrayType, other: _NUMERICAL_TYPE_OR_ARRAY) -> ArrayType: ...
    @overload
    def __truediv__(self: ArrayType, other: WithUnit) -> ValueArray: ...
    def __rtruediv__(self: ArrayType, other: _NUMERICAL_TYPE_OR_ARRAY) -> ArrayType: ...
    def __floordiv__(self, other: Any) -> NDArray[Any]: ...
    def __rfloordiv__(self, other: complex) -> NDArray[Any]: ...
    @overload
    def __mul__(self: ArrayType, other: _NUMERICAL_TYPE_OR_ARRAY) -> ArrayType: ...
    @overload
    def __mul__(self: ArrayType, other: WithUnit) -> ValueArray: ...
    def __rmul__(self: ArrayType, other: _NUMERICAL_TYPE_OR_ARRAY) -> ArrayType: ...
    def __mod__(self: ArrayType, other: Any) -> ArrayType: ...
    def __rmod__(self: ArrayType, other: Any) -> ArrayType: ...
    def __lt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> NDArray[Any]: ...
    def __gt__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> NDArray[Any]: ...
    def __le__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> NDArray[Any]: ...
    def __ge__(self, other: _NUMERICAL_TYPE_OR_ARRAY_OR_GENERIC_UNIT) -> NDArray[Any]: ...
    def __eq__(self, other: Any) -> NDArray[Any]: ...  # type: ignore[override]
    def __neq__(self, other: Any) -> NDArray[Any]: ...

def init_base_unit_functions(
    try_interpret_as_with_unit: Callable[[Any, bool], WithUnit | None],
    is_value_consistent_with_default_unit_database: Callable[[Any], bool],
) -> None: ...
